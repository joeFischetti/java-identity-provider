/*
 * Licensed to the University Corporation for Advanced Internet Development, 
 * Inc. (UCAID) under one or more contributor license agreements.  See the 
 * NOTICE file distributed with this work for additional information regarding
 * copyright ownership. The UCAID licenses this file to You under the Apache 
 * License, Version 2.0 (the "License"); you may not use this file except in 
 * compliance with the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package net.shibboleth.idp.authn;

import java.io.IOException;
import java.security.Principal;
import java.util.Collection;
import java.util.Set;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import javax.security.auth.Subject;

import org.opensaml.storage.StorageSerializer;

import com.google.common.base.Objects;
import com.google.common.base.Predicates;
import com.google.common.collect.Collections2;

import net.shibboleth.utilities.java.support.annotation.Duration;
import net.shibboleth.utilities.java.support.annotation.constraint.NonNegative;
import net.shibboleth.utilities.java.support.annotation.constraint.NonnullElements;
import net.shibboleth.utilities.java.support.annotation.constraint.NotEmpty;
import net.shibboleth.utilities.java.support.annotation.constraint.Unmodifiable;
import net.shibboleth.utilities.java.support.component.IdentifiableComponent;
import net.shibboleth.utilities.java.support.logic.Constraint;
import net.shibboleth.utilities.java.support.primitive.StringSupport;

/**
 * A descriptor for an authentication flow.
 * 
 * <p>A flow models a sequence of profile actions that performs authentication in a particular way and
 * satisfies various constraints that may apply to an authentication request. Some of these constraints are
 * directly exposed as properties of the flow, and others can be found by examining the list
 * of extended {@link Principal}s that the flow exposes.</p>
 */
public class AuthenticationFlowDescriptor implements IdentifiableComponent, PrincipalSupportingComponent,
        StorageSerializer<AuthenticationResult> {

    /** Default serializer for result objects. */
    private static final StorageSerializer<AuthenticationResult> DEFAULT_SERIALIZER;
    
    /** The unique identifier of the authentication flow. */
    @Nonnull @NotEmpty private final String flowId;

    /** Whether this flow supports passive authentication. */
    private boolean supportsPassive;

    /** Whether this flow supports forced authentication. */
    private boolean supportsForced;

    /** Maximum amount of time in milliseconds, since first usage, a flow should be considered active. */
    @Duration @NonNegative private long lifetime;
    
    /** Maximum amount of time in milliseconds, since last usage, a flow should be considered active. */
    @Duration @NonNegative private long inactivityTimeout;
    
    /**
     * Supported principals, indexed by type, that the flow can produce.
     * Implemented for the moment using the Subject class for convenience to allow for class-based
     * lookup in the {@link #getSupportedPrincipals} method.
     */
    @Nonnull private Subject supportedPrincipals;
    
    /** Custom serializer for the results generated by this flow. */
    @Nullable private StorageSerializer<AuthenticationResult> resultSerializer;

    /**
     * Constructor.
     * 
     * @param id unique ID of this flow, can not be null or empty
     */
    public AuthenticationFlowDescriptor(@Nonnull @NotEmpty final String id) {
        flowId = Constraint.isNotNull(StringSupport.trimOrNull(id), "Workflow ID cannot be null or empty");
        supportedPrincipals = new Subject();
    }

    /** {@inheritDoc} */
    @Nonnull @NotEmpty public String getId() {
        return flowId;
    }

    /**
     * Gets whether this flow supports passive authentication.
     * 
     * @return whether this flow supports passive authentication
     */
    public boolean isPassiveAuthenticationSupported() {
        return supportsPassive;
    }

    /**
     * Sets whether this flow supports passive authentication.
     * 
     * @param isSupported whether this flow supports passive authentication
     */
    public void setPassiveAuthenticationSupported(boolean isSupported) {
        supportsPassive = isSupported;
    }

    /**
     * Gets whether this flow supports forced authentication.
     * 
     * @return whether this flow supports forced authentication
     */
    public boolean isForcedAuthenticationSupported() {
        return supportsForced;
    }

    /**
     * Sets whether this flow supports forced authentication.
     * 
     * @param isSupported whether this flow supports forced authentication.
     */
    public void setForcedAuthenticationSupported(boolean isSupported) {
        supportsForced = isSupported;
    }

    /**
     * Gets the maximum amount of time in milliseconds, since first usage, a flow should be considered active. A
     * value of 0 indicates that there is no upper limit on the lifetime on an active flow.
     * 
     * @return maximum amount of time in milliseconds a flow should be considered active, never less than 0
     */
    @NonNegative public long getLifetime() {
        return lifetime;
    }

    /**
     * Sets the maximum amount of time in milliseconds, since first usage, a flow should be considered active. A
     * value of 0 indicates that there is no upper limit on the lifetime on an active flow.
     * 
     * @param flowLifetime the lifetime for the flow, must be 0 or greater
     */
    public void setLifetime(@Duration @NonNegative final long flowLifetime) {
        lifetime = Constraint.isGreaterThanOrEqual(0, flowLifetime, "Lifetime must be greater than or equal to 0");
    }

    /**
     * Gets the maximum amount of time in milliseconds, since the last usage, a flow should be considered active.
     * A value of 0 indicates that there is no inactivity inactivityTimeout on an active flow.
     * 
     * @return the duration.
     */
    @NonNegative public long getInactivityTimeout() {
        return inactivityTimeout;
    }

    /**
     * Sets the maximum amount of time in milliseconds, since the last usage, a flow should be considered active.
     * A value of 0 indicates that there is no inactivity timeout on an active flow.
     * 
     * @param timeout the flow inactivity timeout, must be 0 or greater
     */
    public void setInactivityTimeout(@Duration @NonNegative final long timeout) {
        inactivityTimeout = Constraint.isGreaterThanOrEqual(0, timeout,
                "Inactivity timeout must be greater than or equal to 0");
    }
    
    /**
     * Check if a result generated by this flow is still active.
     * 
     * @param result {@link AuthenticationResult} to check
     * 
     * @return  true iff the result remains valid
     */
    public boolean isResultActive(@Nonnull final AuthenticationResult result) {
        Constraint.isNotNull(result, "AuthenticationResult cannot be null");
        Constraint.isTrue(result.getAuthenticationFlowId().equals(getId()),
                "AuthenticationResult was not produced by this flow");
        
        long now = System.currentTimeMillis();
        if (getLifetime() > 0 && result.getAuthenticationInstant() + getLifetime() <= now) {
            return false;
        } else if (getInactivityTimeout() > 0 && result.getLastActivityInstant() + getInactivityTimeout() <= now) {
            return false;
        }
        
        return true;
    }
    
    /** {@inheritDoc} */
    @Nonnull @NonnullElements @Unmodifiable public <T extends Principal> Set<T> getSupportedPrincipals(
            @Nonnull final Class<T> c) {
        return supportedPrincipals.getPrincipals(c);
    }

    /**
     * Get a collection of supported non-user-specific principals that the flow may produce when it operates.
     * 
     * <p>The {@link Collection#remove()} method is not supported.</p>
     * 
     * @return a live collection of supported principals
     */
    @Nonnull @NonnullElements public Collection<Principal> getSupportedPrincipals() {
        return Collections2.filter(supportedPrincipals.getPrincipals(), Predicates.notNull());
    }
    
    /**
     * Set supported non-user-specific principals that the flow may produce when it operates.
     * 
     * @param <T> a type of principal to add, if not generic
     * @param principals supported principals to add
     */
    public <T extends Principal> void setSupportedPrincipals(@Nonnull @NonnullElements final Collection<T> principals) {
        Constraint.isNotNull(principals, "Principal collection cannot be null.");
        
        supportedPrincipals.getPrincipals().clear();
        supportedPrincipals.getPrincipals().addAll(Collections2.filter(principals, Predicates.notNull()));
    }

    /**
     * Set a custom serializer for results produced by this flow.
     * 
     * @param serializer the custom serializer
     */
    public void setResultSerializer(@Nonnull final StorageSerializer<AuthenticationResult> serializer) {
        resultSerializer = Constraint.isNotNull(serializer, "StorageSerializer cannot be null");
    }


    /** {@inheritDoc} */
    @Nonnull @NotEmpty public String serialize(@Nonnull final AuthenticationResult instance) throws IOException {
        if (resultSerializer != null) {
            return resultSerializer.serialize(instance);
        } else {
            return DEFAULT_SERIALIZER.serialize(instance);
        }
    }

    /** {@inheritDoc} */
    @Nonnull public AuthenticationResult deserialize(int version, @Nonnull @NotEmpty final String context,
            @Nonnull @NotEmpty final String key, @Nonnull @NotEmpty final String value, @Nonnull final Long expiration)
            throws IOException {
        // Back the expiration off by the inactivity timeout to recover the last activity time.
        if (resultSerializer != null) {
            return resultSerializer.deserialize(version, context, key, value,
                    (expiration != null) ? expiration - inactivityTimeout : null);
        } else {
            return DEFAULT_SERIALIZER.deserialize(version, context, key, value,
                    (expiration != null) ? expiration - inactivityTimeout : null);
        }
    }

    /** {@inheritDoc} */
    public int hashCode() {
        return flowId.hashCode();
    }

    /** {@inheritDoc} */
    public boolean equals(Object obj) {
        if (obj == null) {
            return false;
        }

        if (obj == this) {
            return true;
        }

        if (obj instanceof AuthenticationFlowDescriptor) {
            return flowId.equals(((AuthenticationFlowDescriptor) obj).getId());
        }

        return false;
    }

    /** {@inheritDoc} */
    public String toString() {
        return Objects.toStringHelper(this).add("flowId", flowId).add("supportsPassive", supportsPassive)
                .add("supportsForcedAuthentication", supportsForced).add("lifetime", lifetime)
                .add("inactivityTimeout", inactivityTimeout).toString();
    }

    static {
        DEFAULT_SERIALIZER = new DefaultAuthenticationResultSerializer();
    }
}